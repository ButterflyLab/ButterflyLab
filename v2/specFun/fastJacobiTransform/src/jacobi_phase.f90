!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!  This file contains code for constructing nonoscillatory phase functions which
!  represent the solutions of a modified form of Jacobi's differential equation.  The
!  phase and amplitude functions are themselves represented via piecewise chebyshev 
!  expansions.  The routines here are somewhat low level and not intended for direct
!  use by users. 
!
!  More precisely, for a given triple of parameters (dnu,da,db) the subroutines
!  in this file construct a nonoscillatory amplitude function a(t) and a 
!  nonoscillatoryphase function psi(t) such that a(t) cos( psi(t) ) is 
!
!      (da,db)                    (da,db)
!     P        ( cos(t) )  r(t)  C                                                        (1)
!      dnu                        dnu
!
!  where  P_dnu^(da,db) is the Jacobi polynomial of the first kind,
!                                                  
!     r(t) = cos(t/2) ^(db+1/2) sin(t/2) ^(da+1/2),
!
!  and  C_dnu^(da,db) is a normalization constant.   In fact, these routines
!  actually store a modified version of the phase function
!
!    psi(t)/dnu - t 
! 
!  because it is somewhat easier to represent than psi(t) using  piecewise
!  polynomial expansions.  
!
!  The normalization constant is chosen so that (1) and the associated "Q" function 
!  of the second kind  will have Wronskian 1.  The L^2 normalized Jacobi polynomials 
!  are obtained by  multiplying (1) by the constant
!
!       (2*dnu+da+db+1)/pi.
!
!  The following are the principal subroutines in this file:
!
!    jacobi_phase - construct the nonoscillatory phase and amplitude functions
!      representing (1)
!
!    jacobi_phase_disc - return a discretization scheme used to represent
!      the amplitude and phase functions 
!
!    jacobi_phase_eval - evaluate the phase and amplitude functions at a user-specified
!      collection of points using the data generated by jacobi_phase
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



subroutine jacobi_phase(chebdata,dnu,da,db,nints,ab,avals,psivals)
use chebyshev
implicit double precision (a-h,o-z)

double precision, intent(in)              :: dnu,da,db
type(chebexps_data)                       :: chebdata
double precision, intent(in)              :: ab(2,nints)
double precision, intent(out)             :: avals(chebdata%k,nints)
double precision, intent(out)             :: psivals(chebdata%k,nints)

!
!  Construct the phase and amplitude functions for specified values
!  of the parameters.  This routine is a thin wrapper around jacobi_phase_solve.
!
!  Input parameters:
!    chebdata - a chebexps_data structure containing the information needed to
!       manipulate function represented by k-point Chebyshev expansions
!    (dnu,da,db) - the values of the parameters in Jacobi's equation
!    (nints,ab) - the discretization scheme returned by jacobi_phase_disc
!
!  Output parameters:
!    avals - an array of lengh k * nints specifying the values or coefficients
!      of the amplitude function
!    psivals - an array of length k*nints specifying the values of coefficients
!      of the modified phase function
!


data  pi        / 3.14159265358979323846264338327950288d0 /
data  piovertwo / 1.57079632679489661923132169163975144d0 /


call jacobi_phase_solve(chebdata%k,nints,ab,chebdata%xs,                       &
  chebdata%aintr,chebdata%aintr2,chebdata%aintr3,                              &
  chebdata%aintl,chebdata%aintl2,chebdata%aintl3,chebdata%u,                   &
  dnu,da,db,psivals,avals)

end subroutine



subroutine jacobi_phase_disc(nints,ab)
implicit double precision (a-h,o-z)

integer, intent(in)                           :: nints
double precision, intent(out)                 :: ab(2,nints)

!
!  Construct the list of the intervals used to discretize the phase functions.
!
!  Input parameters:
!    nints - the total number of intervals -- this parameter must be even 
!
!     IT IS RECOMMENDED THAT THIS BE SET TO 50 IN ORDER TO USE 20th ORDER CHEBYSHEV
!     EXPANSIONS TO REPRESENT PHASE FUNCTIONS
!
!  Output parameters:
!    ab - a (2,nints) array specifying the endpoints of each interval
!

data  pi        / 3.14159265358979323846264338327950288d0 /
data  piovertwo / 1.57079632679489661923132169163975144d0 /


nints0  = nints/2
dd      = 2.0d0

do int=1,nints0
ab(1,int) = dd**(-nints0+int-1)
ab(2,int) = dd**(-nints0+int)
end do

ab = pi/2*ab

do int=1,nints0
ab(1,nints-int+1) = pi - ab(2,int)
ab(2,nints-int+1) = pi - ab(1,int)
end do

end subroutine



subroutine jacobi_phase_solve(k,nints,ab,xscheb,aintr,aintr2,aintr3, &
  aintl,aintl2,aintl3,u,dnu,da,db,psivals,avals)
use chebyshev
implicit double precision (a-h,o-z)

integer                        :: nints
double precision               :: ab(2,nints),avals(k,nints),psivals(k,nints),u(k,k)
double precision               :: xscheb(k),aintr(k,k),aintr2(k,k),aintr3(k,k)
double precision               :: aintl(k,k),aintl2(k,k),aintl3(k,k)

!
!  Construct the nonoscillatory phase and amplitude functions for Jacobi's differential
!  equation.  These functions are represented via piecewise Chebyshev expansions given
!  on a collection of intervals. 
!

double precision      :: valsmp(k,nints),valsmpp(k,nints),alphap(k,nints)

data  pi        / 3.14159265358979323846264338327950288d0 /
data  piovertwo / 1.57079632679489661923132169163975144d0 /

p    = dnu + (da+db+1)/2

!
!  Handle the case of large p by evaluating square of the amplitude function 
!  and its first two derivatives at the point pi/8 and solving forward and
!  backwards from there
!
if (dnu .gt. 100) then

int0 = nints/2-2
call jacobi_asym_amp(dnu,da,db,c3_0,c2_0,c1_0)

!
!  Solve the ODE backwards, starting from pi/8
!

c1 = c1_0
c2 = c2_0
c3 = c3_0

do int=int0,1,-1
a = ab(1,int)
b = ab(2,int)
call jacobi_solve_back(dnu,da,db,a,b,k,xscheb,aintl,aintl2,aintl3, &
  aintr,aintr2,aintr3,c1,c2,c3,avals(1,int),valsmp(1,int),valsmpp(1,int))
c1 = valsmpp(1,int)
c2 = valsmp(1,int)
c3 = avals(1,int)
end do

!
!  Solve it going forward from pi/8
!

c1 = c1_0
c2 = c2_0
c3 = c3_0

do int=int0+1,nints
a = ab(1,int)
b = ab(2,int)
call jacobi_solve_forward(dnu,da,db,a,b,k,xscheb,aintl,aintl2,aintl3, &
  aintr,aintr2,aintr3,c1,c2,c3,avals(1,int),valsmp(1,int),valsmpp(1,int))
c1 = valsmpp(k,int)
c2 = valsmp(k,int)
c3 = avals(k,int)
end do

else

!
!  For p < 100 use Taylor expansions to evaluate M and its first two derivatives
!  at pi/64
!

int0 = nints/2-5
t    = ab(2,int0)
!t    = pi/64
call jacobi_taylor_m(dnu,da,db,t,c3_0,c2_0,c1_0)

!
!  Solve the ODE backwards
!

c1 = c1_0
c2 = c2_0
c3 = c3_0

do int=int0,1,-1
a = ab(1,int)
b = ab(2,int)
call jacobi_solve_back(dnu,da,db,a,b,k,xscheb,aintl,aintl2,aintl3, &
  aintr,aintr2,aintr3,c1,c2,c3,avals(1,int),valsmp(1,int),valsmpp(1,int))
c1 = valsmpp(1,int)
c2 = valsmp(1,int)
c3 = avals(1,int)
end do

!
!  Solve it going forward from pi/8
!

c1 = c1_0
c2 = c2_0
c3 = c3_0

do int=int0+1,nints
a = ab(1,int)
b = ab(2,int)
call jacobi_solve_forward(dnu,da,db,a,b,k,xscheb,aintl,aintl2,aintl3, &
  aintr,aintr2,aintr3,c1,c2,c3,avals(1,int),valsmp(1,int),valsmpp(1,int))
c1 = valsmpp(k,int)
c2 = valsmp(k,int)
c3 = avals(k,int)
end do

endif

!
!  Construct the phase function via integration 
!

alphap = 1.0d0/avals
c1     = 0
do int=1,nints
a              = ab(1,int)
b              = ab(2,int)
psivals(:,int) = c1 + matmul((b-a)/2*aintl,alphap(:,int))
c1             = psivals(k,int)
end do

!
!  Translate the phase appropriately using Taylor and asymptotic expansions near 0
! 


a2     = 0

if (dnu .le. 100) then
t      = 0.01d0
call jacobi_taylor_p(dnu,da,db,t,valp,derp,der2p)
call jacobi_taylor_q(dnu,da,db,t,valq,derq,der2q)
call chebpw_eval(nints,ab,k,xscheb,psivals,t,psival)
a2 = atan2(valq,valp)-psival

else 

t    = 1/dnu
call jacobi_asym_pder(dnu,da,db,t,valp,derp)
!call jacobi_asym0(dnu,da,db,t,valp,derp)

y  = valp
yp = derp

call chebpw_eval(nints,ab,k,xscheb,avals,t,valm)
call chebpw_eval(nints,ab,k,xscheb,valsmp,t,valmp)
call chebpw_eval(nints,ab,k,xscheb,valsmpp,t,valmpp)
call chebpw_eval(nints,ab,k,xscheb,psivals,t,psival)

apval   = 1/valm
appval  = -valmp/valm**2
apppval = 2*valmp/valm**3 - valmpp/valm**2

c1 = y*sqrt(apval)
c2 = yp/sqrt(apval)+y*appval/(2*apval**(1.5d0))

a1  = sqrt(c1**2+c2**2)
a2  = atan2(c1,c2)

if(a2 .gt. pi) then
a1 = -a1
a2 = a2-pi
endif

if(a2 .le. 0) then
a1 = -a1
a2 = a2 + pi
endif
a2 = a2 - pi/2
a2 = a2 - psival

endif


psivals = psivals + a2
avals   = sqrt(avals)

!
!  Subtract dnu*t and divide by dnu
!

do int=1,nints
a = ab(1,int)
b = ab(2,int)
psivals(:,int) = psivals(:,int)/dnu    -  (xscheb*(b-a)/2+(b+a)/2)
end do
 


! 
!  Convert to coefficient expansions
!

! do int=1,nints
! psivals(:,int) = matmul(u,psivals(:,int))
! avals(:,int)   = matmul(u,avals(:,int))
! end do

end subroutine


subroutine jacobi_solve_back(dnu,da,db,a,b,k,xs,aintl,atinl2,aintl3, &
  aintr,aintr2,aintr3,c1,c2,c3,valsm,valsmp,valsmpp)
implicit double precision (a-h,o-z)

double precision       :: aintr(k,k),aintr2(k,k),aintr3(k,k),xs(k)
double precision       :: aintl(k,k),aintl2(k,k),aintl3(k,k)
double precision       :: valsm(k),valsmp(k),valsmpp(k)

double precision :: qvals(k),qpvals(k),amatr(k,k),xx(k),xx2(k)
double precision :: sigma(k)

!
!  Solve the terminal value problem
!
!      M'''(t) 4 Q(t) M'(t) +  2 Q'(t) M(t) = 0 
!      M(b) = c3,  M'(b) = c2, M''(b) = c1
!
!  on the interval (a,b).  The square of the amplitude function satisfies
!  this equation.
!

data  pi        / 3.14159265358979323846264338327950288d0 /
data  piovertwo / 1.57079632679489661923132169163975144d0 /

dd   = (b-a)/2
xx = xs*(b-a)/2 + (a-b)/2
xx2 = 0.125d0 * (a-b)**2 * (xs-1)**2

!
!  Evaluate Q and its derivative at the specified points
!

do i=1,k
t         = (b-a)/2 * xs(i) + (b+a)/2

qvals(i)  = dnu*(1+da+db+dnu)+((1+da+db-1.d0*(-da+  &
db)*Cos(t))*1/sin(t)**2)/2.d0-((1+da+db)*cos(t)/sin(t)-1.d0*(-da+db)*&
  1/sin(t))**2/4.d0

qpvals(i) = (((-2+4.d0*da**2+4.d0*db**2)*Cos(t)+(da-1.d0*db)*(da  &
+db)*(3+Cos(2.d0*t)))*1/sin(t)**3)/4.d0
end do

!
!  Form the linear system to solve ...
!

do i=1,k
amatr(i,:) = 4*qvals(i) *aintr2(i,:)*dd**2 + 2 * qpvals(i) * aintr3(i,:)*dd**3
end do
do i=1,k
amatr(i,i) = amatr(i,i)+ 1.0d0
end do

sigma = -4*qvals * ( c2 + c1 * xx ) - 2 * qpvals * (c3 + c2 * xx + c1 * xx2)

!
!  ... and solve it 
!

call jacobi_phase_qrsolv(amatr,k,sigma)

valsmpp = c1 + matmul(aintr*dd,sigma)
valsmp  = c2 + matmul(aintr*dd,valsmpp)
valsm   = c3 + matmul(aintr*dd,valsmp)

end subroutine


subroutine jacobi_solve_forward(dnu,da,db,a,b,k,xs,aintl,aintl2,aintl3, &
  aintr,aintr2,aintr3,c1,c2,c3,valsm,valsmp,valsmpp)
implicit double precision (a-h,o-z)

double precision       :: aintl(k,k),aintl2(k,k),aintl3(k,k),xs(k)
double precision       :: aintr(k,k),aintr2(k,k),aintr3(k,k)
double precision       :: valsm(k),valsmp(k),valsmpp(k)

double precision       :: qvals(k),qpvals(k),amatr(k,k),xx(k),xx2(k)
double precision       :: sigma(k)

!
!  Solve the initial value problem
!
!      M'''(t) + 4 Q(t) M'(t) +  2 Q'(t) M(t) = 0 
!      M(a) = c3,  M'(a) = c2, M''(a) = c1
!
!  on the interval (a,b).  The square of the amplitude function satisfies
!  this equation.
!

;double precision :: ones(k)

data  pi        / 3.14159265358979323846264338327950288d0 /
data  piovertwo / 1.57079632679489661923132169163975144d0 /

dd   = (b-a)/2

! ones = 1
! xx   = matmul(dd*aintl,ones)
! xx2   = matmul(dd*aintl,xx)

xx  = xs*(b-a)/2 + (b-a)/2
xx2 = 0.125d0 * (a-b)**2 * (xs+1)**2

!
!  Evaluate Q and its derivative at the specified points
!

do i=1,k
t         = (b-a)/2 * xs(i) + (b+a)/2

qvals(i)  = dnu*(1+da+db+dnu)+((1+da+db-1.d0*(-da+  &
db)*Cos(t))*1/sin(t)**2)/2.d0-((1+da+db)*cos(t)/sin(t)-1.d0*(-da+db)*&
  1/sin(t))**2/4.d0

qpvals(i) = (((-2+4.d0*da**2+4.d0*db**2)*Cos(t)+(da-1.d0*db)*(da  &
+db)*(3+Cos(2.d0*t)))*1/sin(t)**3)/4.d0

end do

!
!  Form the linear system to solve ...
!

do i=1,k
amatr(i,:) = 4*qvals(i) *aintl2(i,:)*dd**2 + 2 * qpvals(i) * aintl3(i,:)*dd**3
end do
do i=1,k
amatr(i,i) = amatr(i,i)+ 1.0d0
end do

sigma = -4*qvals * ( c2 + c1 * xx ) - 2 * qpvals * (c3 + c2 * xx + c1 * xx2)

!
!  ... and solve it 
!

call jacobi_phase_qrsolv(amatr,k,sigma)

valsmpp = c1 + matmul(aintl*dd,sigma)
valsmp  = c2 + matmul(aintl*dd,valsmpp)
valsm   = c3 + matmul(aintl*dd,valsmp)

end subroutine



subroutine jacobi_phase_eval(chebdata,dnu,da,db,nints,ab,avals,psivals,nts,ts,avals0,psivals0)
use chebyshev
implicit double precision (a-h,o-z)

type(chebexps_data)                         :: chebdata
integer, intent(in)                         :: nints,nts
double precision, intent(in)                :: ab(2,nints),ts(nts)
double precision, intent(in)                :: avals(chebdata%k,nints)
double precision, intent(in)                :: psivals(chebdata%k,nints)
double precision, intent(out)               :: avals0(nts),psivals0(nts)

!  
!  Evaluate the phase and amplitude functions associated with the data
!  generated by the jacobi_phase subroutine at a user-specified collection
!  of points in the interval (0,\pi).
!
!  IMPORTANT WARNING: the list of points must be sorted in INCREASING ORDER
!
!  Input parameters:
!    chebdata - a chebexps_data structure containing the information needed to
!       manipulate function represented by k-point Chebyshev expansions
!    (nints,ab) - the discretization scheme for the phase functions
!    (avals,psivals) - the representations of the phase and amplitude functions 
!       generated by jacobi_phase
!
!    nts - the number of points at which to evaluate the Jacobi function
!     of the first kind
!    ts - a list of the points at which to evaluate the Jacobi function;
!     THESE MUST BE IN INCREASING ORDER
!
!  Output parameters:
!    avals - a user-supplied vector of length nts which will contain
!     the values of the amplitude function on return
!    psivals - a user-supplied vector of length nts which will contain
!     the values of the phase function on return
!    


double precision, allocatable :: ts0(:)
data  pi        / 3.14159265358979323846264338327950288d0 /
data  piovertwo / 1.57079632679489661923132169163975144d0 /
data  log2      / 0.69314718055994530941723212145817657d0 /

p    = dnu + (da+db+1)/2
eps0 = epsilon(0.0d0)

! L^2 normalization
dconst  = sqrt( (2*dnu+da+db+1)/pi )

! Wronskian normalization
!dconst = 1

int0 = 1
k    = chebdata%k

do j=1,nts
t   = ts(j)

! u   = (t - 1.0d-7)/(pi/2-1.0d-7)
! ii  = log(u)/log2
! int = (phase%nints+ii)

do int=int0,nints-1
b = ab(2,int)
if (t .lt. b) exit
end do


a    = ab(1,int)
b    = ab(2,int)
int0 = int


! call chebeval(a,b,k,chebdata%xs,avals(:,int),t,aval)
! call chebeval(a,b,k,chebdata%xs,psivals(:,int),t,psival)

xx   = (2*t - (b+a) ) /(b-a)
sum1 = 0
sum2 = 0
sum3 = 0


dd1 = 1.0d0
do i=1,k
dd=1.0d0
if (i .eq. 1 .OR. i .eq. k) dd = 0.5d0
diff = xx-chebdata%xs(i)
!
!  Handle the case in which the target node coincides with one of
!  the Chebyshev nodes.
!

if(abs(diff) .le. eps0) then
aval   = avals(i,int)
psival = psivals(i,int)
goto 1000
endif

!
!  Otherwise, construct the sums.
!

dd   = (dd1*dd)/diff
dd1  = - dd1
sum1 = sum1+dd*avals(i,int)
sum2 = sum2+dd
sum3 = sum3+dd*psivals(i,int)
dd   = - dd
end do

aval    = sum1/sum2
psival  = sum3/sum2

1000 continue

psivals0(j) = (psival +t )*dnu
avals0(j)   = aval * dconst
end do


end subroutine






subroutine jacobi_phase_qrsolv(a,n,rhs)
implicit double precision (a-h,o-z)

integer            :: n
double precision   :: a(n,n),rhs(n)

!
!  This subroutine uses a version of QR-decomposition to solve the equation
!  A x = b.  The input matrix a is destroyed by this routine.
!
!  Input parameters:
!    a - the (n,n) matrix of coefficients WHICH WILL BE DESTROYED BY THIS
!     ROUTINE
!    n - an integer specifying the size of the system of 
!    rhs - a vector of length n speciying the rhs of the system
!
!  Output parameters:
!   rhs - upon return, the solution of the linear system
!

double precision :: aa(2),u(2,2)

! 
! transpose the input matrix a 
!

size22=0
do i=1,n
do j=1,i
d=a(j,i)
a(j,i)=a(i,j)
a(i,j)=d
size22=size22+a(j,i)**2
size22=size22+a(i,j)**2
end do
end do

!
!  Reduce to upper triangular 
!
do i=1,n-1
do j=n,i+1,-1
aa(1)=a(i,j-1)
aa(2)=a(i,j)

u22=-aa(1)
u12=aa(2)
d=u22**2+u12**2
if(d .lt. size22*1.0d-66) then
u(2,2)=1
u(1,2)=0
u(1,1)=1
u(2,1)=0
else
d=sqrt(d)
u(2,2)=u22/d
u(1,2)=u12/d
u(1,1)=-u(2,2)
u(2,1)=u(1,2)
endif

do ii=i,n
d1=u(1,1)*a(ii,j-1)+u(1,2)*a(ii,j)
d2=u(2,1)*a(ii,j-1)+u(2,2)*a(ii,j) 
a(ii,j-1)=d1
a(ii,j)=d2
end do

d1=u(1,1)*rhs(j-1)+u(1,2)*rhs(j)
d2=u(2,1)*rhs(j-1)+u(2,2)*rhs(j)
rhs(j-1)=d1
rhs(j)=d2
end do
end do

!
!  Apply the inverse of the triangular matrix
! 

rhs(n)=rhs(n)/a(n,n)
do i=n-1,1,-1
d=0
do j=n,i+1,-1
d=d+a(j,i)*rhs(j)
end do
rhs(i)=(rhs(i)-d)/a(i,i)
end do

end subroutine
